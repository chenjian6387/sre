# 22-web通信协议篇

# web通信流程

在开始学web服务器之前，需要先理解web通信协议，才能够更好的吸收其中精华。

我们平时浏览⽹⻚的时候,会打开浏览器，输⼊⽹址后按下回⻋键，然后就会显示出你想要浏览的内容。在这个看似简单的⽤户⾏为背后，到底隐藏了些什么呢？

- 浏览器本身是⼀个客户端，当你输⼊URL的时候，⾸先浏览器会去请求DNS服务器，通过DNS获取相应的域名对应的IP
- 然后通过IP地址找到IP对应的服务器后，要求建⽴TCP连接
- 等浏览器发送完HTTP Request（请求）包后，服务器接收到请求包之后才开始处理请求包
- 服务器调⽤⾃身服务，返回HTTP Response（响应）包；
- 客户端收到来⾃服务器的响应后开始渲染这个Response包⾥的主体（body），等收到全部的内容随后断开与该服务器之间的TCP连接。

![image-20220506153003155](http://book.bikongge.com/sre/2024-linux/image-20220506153003155.png)

⼀个Web服务器也被称为HTTP服务器，它通过HTTP协议与客户端通信。

这个客户端通常指的是Web浏览器。

# web服务器工作原理

Web服务器的⼯作原理可以简单地归纳为:

- 客户端通过TCP/IP协议建⽴到服务器的TCP连接
- 客户端向服务器发送HTTP协议请求包，请求服务器⾥的资源⽂档
- 服务器向客户端发送HTTP协议应答包，如果请求的资源包含有动态语⾔的内容，那么服务器会调⽤动态语⾔ 的解释引擎负责处理“ 动态内容”，并将处理得到的数据返回给客户端
- 客户端与服务器断开。由客户端解释HTML⽂档，在客户端屏幕上渲染图形结果

# 客户端请求到达服务端流程

- 当客户端拿到服务端域名对应的ip后，浏览器会以一个随机端口（1024<随机端口<65535）向服务器的web程序（nginx、apache）的80端口发起tcp连接请求。
- 该请求经过复杂的网络环境后到达服务端，进入到服务器的对应的网卡，再进入到linux内核的tcp/ip协议栈，一层一层的解开数据包，甚至经过防火墙，最终到达nginx程序，确认tcp/ip连接。
- 确认tcp连接之后，客户端继续发起http请求，如常见的get、post请求方法。

# 小结

因此你会发现，web通信原理中，主要分两块协议的建立

- tcp/ip
- http

# TCP/IP协议

传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

简单说就是TCP协议就是控制数据包在传过过程中的规范格式。

IP是Internet Protocol（网际互连协议）的缩写，是TCP/IP体系中的网络层协议。

设计IP的目的是提高网络的可扩展性：一是解决互联网问题，实现大规模、异构网络的互联互通；二是分割顶层网络应用和底层网络技术之间的耦合关系，以利于两者的独立发展。

根据端到端的设计原则，IP只为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务。

> TCP/IP协议指的不仅仅是tcp、和ip这两个协议。
>
> 而是由FTP、SMTP、TCP、UDP、IP等各种协议组成的协议簇，但是TCP/IP最最具有代表性，因此俗称TCP/IP协议。

# OSI七层模型

提到tcp/ip协议，就不得不学一下OSI七层模型。

请看本文

```
http://apecome.com:9494/02%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/2-1-OSI%E6%A8%A1%E5%9E%8B%E4%B8%8ETCP%E5%8D%8F%E8%AE%AE.html
```

![image-20220120151241369](http://book.bikongge.com/sre/2024-linux/image-20220120151241369.png)

# TCP/IP三次握手

![image-20220123171403936](http://book.bikongge.com/sre/2024-linux/image-20220123171403936.png)

讲解 TCP 三次握手和四次握手之前，我们先了解一下 TCP 和 UDP 这两个重量级的传输层协议。

💦 **用户数据报协议 UDP**（User Datagram Protocol）：

- **UDP 在传送数据之前不需要先建立连接**，远程主机在收到 UDP 报文后，不需要给出任何确认。
- 虽然 UDP **不提供可靠交付**，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等

💦 **传输控制协议 TCP**（Transmission Control Protocol）：

- TCP 提供**面向连接**的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。
- TCP 不提供广播或多播服务。由于 TCP 要提供**可靠**的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。
- TCP **一般用于文件传输、发送和接收邮件、远程登录等场景**。

## TCP数据报文首部格式

![image-20220123171521805](http://book.bikongge.com/sre/2024-linux/image-20220123171521805.png)

关于TCP/IP数据报文的所有字段不需要记忆，只需要关注如下的关键字即可

## 关于TCP首部重要字段的解释

- 源端口、目的端口

  - 各占 2 个字节，分别写入源端口和目的端口。IP 地址 + 端口号就可以确定一个进程地址

- **序号/序列号**（Sequense Number）

  - 在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。
  - 例如，一报文段的序号是 101，共有 100 字节的数据。（seq=101）
    - 这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。
    - 显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。（seq=201）

  ![image-20220506203943995](http://book.bikongge.com/sre/2024-linux/image-20220506203943995.png)

- **确认号 ack**（注意大小写）

  - 期望收到对方下一个报文段的第一个数据字节的序号。
  - 若确认号为ack=N，则表明：到序号 N-1 为止的所有数据都已正确收到。

## TCP标志位解释

- **确认 ACK**：仅当 ACK = 1 时确认号字段才有效，当 ACK = 0 时确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。

- **同步 SYN**

  SYN = 1 表示这是一个连接请求或连接接受报文。

  当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 且 ACK = 1。

- **终止 FIN**：用来释放一个连接。当 FIN = 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。

> 大写的表示标志位
>
> 小写的表示TCP首部字段

## 详解tcp握手、挥手

**最开始的时候客户端和服务器都是处于CLOSED状态。**

**主动打开连接的为客户端，被动打开连接的是服务器。**

> 你在打开小电影网站之前，你和网站是没有联系的，在你打开网页之后，你们之间就建立了TCP连接。

![image-20220506174531218](http://book.bikongge.com/sre/2024-linux/image-20220506174531218.png)

### 图解三次握手(真理)

三次握手的原文是 `three-way handshake`，整个名词的可以翻译为：**需要三个步骤才能建立握手/连接的机制**。当然，三次握手也可以叫 `three-message handshake`，通过三条消息来建立的握手/连接。

进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的 **初始化序列号(Init Sequense Number, `ISN`)** 为后面的可靠性传输做准备。

三次握手过程如下图：

![image-20220506212122066](http://book.bikongge.com/sre/2024-linux/image-20220506212122066.png)

## 抓包查看三次握手（真理）

鼎鼎大名的tcp/ip协议的三次握手、也就是关乎于`syn、syn/ack、ack`三个标识位

tcp是一个及其复杂的知识点，这里咱们通过wireshare来尽量的通过实践，理解tcp的序列号和确认号的关系。

TCP协议正在报文中使用了大量的标志位来控制tcp的连接状态；

最主要的三个标志位如下

- SYN、创建一个连接
- FIN、终止一个连接
- ACK、确认接收到了数据

### 第一次握手（SYN）

> 打开tcp层的数据包信息，展开TCP的标志位区域（flag），可以看到tcp用到的所有标志位。

![image-20220506191929388](http://book.bikongge.com/sre/2024-linux/image-20220506191929388.png)

### 第二次握手（SYN、ACK）

往下看

### 第三次握手（ACK）

![image-20220506192940500](http://book.bikongge.com/sre/2024-linux/image-20220506192940500.png)

# TCP/IP四次挥手

![image-20220506174548456](http://book.bikongge.com/sre/2024-linux/image-20220506174548456.png)

数据传输完毕后，双方都可释放连接。

最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。

![image-20220507105301758](http://book.bikongge.com/sre/2024-linux/image-20220507105301758.png)

## 抓包查看四次挥手

### 1.FIN、

### 2.ACK、

### 3.FIN

### 4.ACK

![image-20220507111716019](http://book.bikongge.com/sre/2024-linux/image-20220507111716019.png)

# TCP连接状态报文

面试时候拿出来背诵即可

```
CLOSE 没有任何连接状态
LISTEN 监听状态、等待来自TCP的连接请求
SYN-SENT 发送连接请求后，等待对方确认
SYN-RECEIVED 收到、发送一个连接请求后，等待对方确认
ESTABLISHED   代表传输连接已经建立，双方进入数据传输状态
FIN-WAIT-1         主动关闭1，主机已发送关闭连接请求，等待对方确认
FIN-WAIT-2        主动关闭2，主机已收到对方关闭传输连接的确认，等待对方发送关闭传输连接请求

TIME-WAIT 完成双向传输连接关闭，等待服务端最终确认
CLOSE-WAIT 被动关闭连接，收到对方发来的关闭连接请求，且已经确认。
LAST-ACK  被动关闭，等待最后一个关闭传输连接的确认。
CLOSE        双方同时确认了关闭传输连接
```

# 常用的熟知端口号

| 应用程序   | FTP   | TFTP | TELNET | SMTP | DNS  | HTTP | SSH  | MYSQL |
| ---------- | ----- | ---- | ------ | ---- | ---- | ---- | ---- | ----- |
| 熟知端口   | 21,20 | 69   | 23     | 25   | 53   | 80   | 22   | 3306  |
| 传输层协议 | TCP   | UDP  | TCP    | TCP  | UDP  | TCP  | TCP  | TCP   |

# TCP与套接字(socket)

通过前面对OSI网络模型的学习，我们知道了在网络层中可以通过IP地址实现两个机器之间的通信。

但是这并不具体，因为，真正进行通信的实体是在主机中的进程，是一个主机中的一个进程与另外一个主机中的一个进程在交换数据。

> 为什么必须是TCP/IP俩协议的结合？
>
> 因为

IP协议虽然能把数据报文送到目的主机，但是并没有交付给主机的具体应用进程。

而端到端的通信才应该是应用进程之间的通信，也就是port对port。

因此必须是tcp+ip协议的组合，才是一个可用的连接。

> TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字
>
> 例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80

## 网络套接字的应用

上面说了socket套接字，就是ip+port，具体的表现为如

mysql服务的运行

```
172.16.1.51:3306
```

nginx服务的运行

```
172.16.1.7:80
```

## 本地套接字的应用

部署一些应用，如django也可以设置为本地socket套接字文件形式，而非ip+port的网络socket形式。这个以后学习nginx部署再说。

总之、socket都是能够具体定位到一个应用进程，获取数据。

```
例如mysql服务端的启动，有两种方式形式

1.远程的通过网络连接TCP/IP  ，进行 如123.206.16.61:3306访问

2.本地进程连接，比TCP更快，使用unix domain socket作为通信载体。

这个等学习mysql时候，于超老师再进行讲解。本次理解概念即可。
```

至此，关于网络连接的TCP原理结束，往下就是HTTP应用层的协议了。

# HTTP协议

## HTTP协议简介

```
超文本传输协议（英文：**H**yper**T**ext **T**ransfer **P**rotocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。

HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。

2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。
```

## HTTP协议概述

HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。

- 通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。
- 我们称这个客户端为用户代理程序（user agent）。
- 应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。
- 在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。
- 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。
- HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。

## HTTP工作原理

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。

HTTP协议采用了请求/响应模型。

客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

## HTTP 请求/响应的步骤

![img](http://book.bikongge.com/sre/2024-linux/877318-20180418160227278-698810818.png)

```
1. 客户端连接到Web服务器
一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.yuchaoit.cn

2. 发送HTTP请求
通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

3. 服务器接受请求并返回HTTP响应
Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。


4. 客户端浏览器解析HTML内容
客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。
客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

5. 释放连接TCP连接
若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;
```

例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：

1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
2. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
3. 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
5. 浏览器将该 html 文本并显示内容; 　
6. 释放 TCP连接;

> 总结
>
> **http协议是基于TCP/IP协议之上的应用层协议。**

### 请求-响应的模式

HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。

换句话说,肯定是先从客户端开始建立通信的,服务器端在没有接收到请求之前不会发送响应

![img](http://book.bikongge.com/sre/2024-linux/877318-20180418160433297-1726664935.png)

### HTTP无状态

HTTP是一种不保存状态,即无状态(stateless)协议。

HTTP协议 自身不对请求和响应之间的通信状态进行保存。

也就是说在HTTP这个级别,协议对于发送过的请求或响应都不做持久化处理。

![img](http://book.bikongge.com/sre/2024-linux/877318-20180418160546133-1479186889.png)

这种无状态设计是为了保证HTTP可以处理大量的请求响应；

### cookie

但是如果HTTP完全无状态，你登录到淘宝网后，点击电子产品的跳转链接，它又提示你需要登录了，这就是一个无状态的实际效果。

因此此类需要保持用户身份信息的业务，必须要保存用户的状态。

于是引入了Cookie技术，能够保持用户的身份信息，下一次客户端发出请求，服务端能记忆客户端的身份。

没有cookie

![image-20220507114658679](http://book.bikongge.com/sre/2024-linux/image-20220507114658679.png)

有cookie

![image-20220507115035170](http://book.bikongge.com/sre/2024-linux/image-20220507115035170.png)

# HTTP请求方法

```
HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：

GET
向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据

HEAD
与GET方法一样，都是向服务器发出指定资源的请求。
只请求响应报文中的HTTP头部。
它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。

POST
向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。
如注册、登录等请求。

PUT
向指定资源位置上传其最新内容。
如更新用户信息


DELETE
请求服务器删除Request-URI所标识的资源。

TRACE
回显服务器收到的请求，主要用于测试或诊断。

OPTIONS
这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。

CONNECT
HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。

注意事项：

方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。

HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。
```

# HTTP请求报文

![image-20220507133149538](http://book.bikongge.com/sre/2024-linux/image-20220507133149538.png)

```
Accept 就是告诉服务器端，我接受那些MIME类型

Accept-Encoding 这个看起来是接受那些压缩方式的文件

Accept-Lanague 告诉服务器能够发送哪些语言

Connection 告诉服务器支持keep-alive特性

Cookie 每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端

Host 用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多

虚拟主机．那这里就是用来标识要访问那个虚拟主机。

User-Agent 用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜引擎的蜘蛛等

If-Modified-Since 是浏览器向服务器端询问某个资源文件如果自从什么时间修

过，那么重新发给我，这样就保证服务器端资源．文件更新时，浏览器再次去

求，而不是使用缓存中的文件。

If-None-Match：本地缓存中存储的文档的ETag标签是否与服务器文档的Etag不匹配；
```

| 报文格式     | 报文信息                        |
| ------------ | ------------------------------- |
| 请求行       | 请求方法                        |
|              | 请求URL                         |
|              | 请求协议                        |
| 请求头       | 字段1 ： 值1                    |
|              | 字段2 ： 值2                    |
| 空白行       |                                 |
| 请求报文主体 | GET方法不提交数据，没有报文主体 |
|              | POST方法提交数据，携带报文主体  |
|              |                                 |

## 抓包HTTP请求

![image-20220507140239014](http://book.bikongge.com/sre/2024-linux/image-20220507140239014.png)

# HTTP响应报文

![image-20220507134120338](http://book.bikongge.com/sre/2024-linux/image-20220507134120338.png)

```
响应头解释
Connection            使用keep-alive特性
Content-Encoding      使用gzip方式对资源压缩
Content-Length: 主体的长度
Content-type          MIME类型为html类型，字符集是 UTF-8
Date                  响应的日期
Server                使用的WEB服务器
Last-Modified：最后一次修改的时间
Server：            服务器程序软件名称和版本
```

| 报文格式     | 报文信息                                  |
| ------------ | ----------------------------------------- |
| 起始行       | 协议版本号                                |
|              | 数字状态码                                |
|              |                                           |
| 响应头部     | 字段1：值1                                |
|              | 字段2：值2                                |
| 响应报文主体 | `<html>于超老师带你学IT，牛啊牛啊</html>` |
|              |                                           |
|              |                                           |
|              |                                           |

## 抓包HTTP响应

![image-20220507140418161](http://book.bikongge.com/sre/2024-linux/image-20220507140418161.png)

# HTTP常见响应状态码

状态代码的第一个数字代表当前响应的类型：

- 1xx消息——请求已被服务器接收，继续处理
- 2xx成功——请求已成功被服务器接收、理解、并接受
- 3xx重定向——需要后续操作才能完成这一请求
- 4xx请求错误——请求含有词法错误或者无法被执行（客户端的错误）
- 5xx服务器错误——服务器在处理某个正确请求时发生错误（服务端的错误）

## 常见状态码

```
一些常见HTTP状态码为：
200 – 服务器成功返回网页
404 – 请求的网页不存在
503 – 服务不可用

常见HTTP状态码大全

1xx（临时响应）
表示临时响应并需要请求者继续执行操作的状态代码。

代码 说明
http状态码 100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
http状态码 101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。

2xx （成功）
表示成功处理了请求的状态代码。
代码 说明
http状态码 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
http状态码 201 （已创建） 请求成功并且服务器创建了新的资源。
http状态码 202 （已接受） 服务器已接受请求，但尚未处理。
http状态码 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。
http状态码 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。
http状态码 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。
http状态码 206 （部分内容） 服务器成功处理了部分 GET 请求。

3xx （重定向）
表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

代码 说明
http状态码 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
http状态码 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
http状态码 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
http状态码 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
http状态码 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
http状态码 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
http状态码 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

4xx（请求错误）
这些状态代码表示请求可能出错，妨碍了服务器的处理。

代码 说明
http状态码 400 （错误请求） 服务器不理解请求的语法。
http状态码 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
http状态码 403 （禁止） 服务器拒绝请求。
http状态码 404 （未找到） 服务器找不到请求的网页。
http状态码 405 （方法禁用） 禁用请求中指定的方法。
http状态码 406 （不接受） 无法使用请求的内容特性响应请求的网页。
http状态码 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
http状态码 408 （请求超时） 服务器等候请求时发生超时。
http状态码 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
http状态码 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。
http状态码 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。
http状态码 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。
http状态码 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
http状态码 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。
http状态码 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。
http状态码 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。
http状态码 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。

5xx（服务器错误）
这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

代码 说明
http状态码 500 （服务器内部错误） 服务器遇到错误，无法完成请求。
http状态码 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
http状态码 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
http状态码 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
http状态码 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
http状态码 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。
```

# URL/URI理解

统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。

例如身份证号，定位唯一的一个人，绝对不会重复，身份证号就好比是URI

统一资源定位符URL 定位到这个人，他在哪

```
住址协议://地球/中国/北京/昌平/沙河/于超老师
```

等于↓

```
http://yuchaoit.cn/upload/2022/05/Xnip2022-05-01_16-32-30-b82235c9b62c42af8ea25e0313ca42f7.jpg
```

url中文叫“统一资源标识符”，是一个用于标识某一互联网资源名称的字符串，在世界范围内标识定位某一个唯一信息资源。

```
其实这个资源就是在web服务器上
[root@yuchao-tx-server /opt]#find / -name 'Xnip2022-05-01_16-32-30-b82235c9b62c42af8ea25e0313ca42f7.jpg'

/root/.halo/upload/2022/05/Xnip2022-05-01_16-32-30-b82235c9b62c42af8ea25e0313ca42f7.jpg
```

url主要用在各种www客户端和服务器程序上，url可以用一种统一的格式来描述各种信息资源，包括文件，服务器地址和目录等

【url组成】

1. 协议
2. 主机ip或域名
3. 端口
4. 文件资源具体地址

第一部分用"://"隔开，第二部分用"/"符号隔开

# web服务器与前端静态资源

部署web服务器的作用，一般都是响应前端静态资源，因此和HTML、CSS、JS等资源结合密切。

通过浏览器的抓包工具即可看到效果。

## html

超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。

http服务器响应体，一般就是如下的html

```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>chaoge.linux</title>
</head>
<body>
    <h1>我的第一个标题</h1>
    <p>我的第一个段落。</p>
</body>
</html>
```

## css

CSS 指层叠样式表 (**C**ascading **S**tyle **S**heets)

CSS作用是定义如何显示HTML元素样式

![image-20220507141208261](http://book.bikongge.com/sre/2024-linux/image-20220507141208261.png)

## js

JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。

JavaScript 是一种轻量级的编程语言。

JavaScript 是可插入 HTML 页面的编程代码。

JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。

![image-20200113174821025](http://book.bikongge.com/sre/2024-linux/image-20200113174821025.png)

# 静态资源理解

在网页设计中，纯HTMl格式的网页（包含图片，视频，JS，CSS等样式）通常被称作“静态网页”。

静态网页是相对于动态网页而言的，是指没有后台数据库，不包含程序，不可交互的网页。

```
静态网页的特点
开发人员写了什么，显示就是什么，一旦编写完成，就不会有任何改变。静态网页一般适用于更新较少的展示型网页，例如（酒水，家具，水果等宣传页），是很多中小网站的展示方式。
```

静态网页资源对应文件扩展名为

- 纯文本文件，如.htm .html .xml .js .css
- 图片或数据文档，如 .jpg .gif .bmp .txt .ppt
- 视频类文件 .mp4 .avi .flv 等

静态网页重要特性

- 每个页面有一个固定的url地址，url地址不含有问号"?"或"&"等符号
- 网页一经发布到服务器，网页内容是保存在服务器文件系统上的，每个网页都是独立的一个文件
- 网页内容固定不变，容易被搜索引擎收录（优点）
- 网页没有数据库支撑，在网站制作和维护上工作量很大（缺点）
- 网页的交互性很差，缺少程序的功能实现（缺点）
- 客户端解析网址时，由于不需要读取数据库，因此服务器端可以接受更高的并发访问。请求到来时，直接从磁盘上返回数据。（优点）

# 动态资源理解

```
服务端需要通过执行程序做出处理，发送给客户端的是程序的运行结果
动态网页是和静态网页相对而言的，动态网页的url后缀一般是.asp  .aspx  .php .js .cgi 
并且动态网页都有标志性的符号"? &"，后端都有数据库的支持。
```

动态网页地址

```
添加新随笔
https://i.cnblogs.com/EditPosts.aspx?opt=1
```

动态网页资源特点

1. 网页以数据库技术为支撑，大大降低网站维护的工作量
2. 动态网页技术的网站可以实现更多的功能，如用户注册，用户登录，投票，用户管理，博客管理等
3. 动态网页不是独立存在服务器上的网页文件，用户请求动态程序时，服务器解析程序并且可能读取数据库返回一个完整的网页内容
4. 搜索引擎（爬虫）一般不会抓取网址中的“？”后面的内容，因此企业都会做伪静态技术页面

> 不同编程语言，设计的动态url是不一样的，需要自行通过抓包工具，分析请求头信息。

![image-20220507141536002](http://book.bikongge.com/sre/2024-linux/image-20220507141536002.png)

# 总结（面试背诵）

一个url在浏览器回车之后，发生了什么

```
1.dns篇
用户访问域名www.yuchaoit.cn
↓
浏览器跳转
↓
浏览器缓存（disk cache）
↓
Hosts文件
↓
本地DNS服务器（递归查询 > 迭代查询）
↓
client 向 server发起查询（递归查询）
server 向 server发起查询（迭代查询）


2.TCP/IP协议篇（三次握手）
client > SYN报文，请求连接 
server > SYN，ACK报文 响应client
client  > ACK，建立连接 


3.客户端发起http请求
- 请求方法是什么、get、post、delete
- 请求主机是什么、www.yuchaoit.cn
- 请求资源是什么 、 http://yuchaoit.cn:8090/upload/2022/05/Xnip2022-05-01_16-32-30-b82235c9b62c42af8ea25e0313ca42f7.jpg
- 请求端口是什么、默认http是80、https是443
- 请求参数是什么、请求头部信息（资源类型、是否压缩、cookie、浏览器客户端等）
- 请求信息最后的换行

4.服务端响应的内容
- server信息（web服务器软件类型）
- 响应文件类型
- 响应头部信息（是否压缩，语言编码，是否保持连接等）

5.客户端发起TCP四次挥手断开连接。
client > 发起断开请求 FIN=1 
server  > 响应断开   FIN、ACK
server  > 发起断开请求 FIN=1
client > 确认断开连接 ACK
```