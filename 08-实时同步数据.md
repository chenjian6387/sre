#  08-实时同步数据

# 数据备份的重要性

网站集群架构中，数据永远是最核心且重要的，数据丢失，将会给企业造成巨大损失

![image-20220215182149454](http://book.bikongge.com/sre/2024-linux/image-20220215182149454.png)

------

------

![image-20220215182202013](http://book.bikongge.com/sre/2024-linux/image-20220215182202013.png)

------

------

![image-20220215182344999](http://book.bikongge.com/sre/2024-linux/image-20220215182344999.png)

# 数据备份方案

企业网站和应用都得有完全的数据备份方案确保数据不丢失，通常企业有如下的数据备份方案

# 定时任务定期备份

需要周期性备份的数据可以分两类：

- 后台程序代码、运维配置文件修改，一般会定时任务执行脚本进行文件备份，然后配置Rsync工具推送到远程服务器备份
- 对于数据库文件用定时任务脚本配合数据库提供的备份工具，定时生成备份文件，配合Rsync备份到远端

# 为什么要用实时同步服务

因为定时任务有缺陷，一分钟以内的数据无法进行同步，容易造成数据丢失

# 实时复制方案

实施复制是最适合企业备份重要数据的方式，用于用户提交的数据备份，对于用户提交的普通文件（jpg、tar、zip、MP4、txt、html）等待，都可以用`Inofity+Rsync`实时备份方案。

对于数据文件，还有更复杂的分布式存储方案，把数据同时备份成多份，如FastDFS、GlusterFS等

对于提交到数据库中的数据，还可以用数据库的主从复制（如MySQL），这是软件自带的实时备份。

# 图解备份方式

## rsync+crond定时备份

![image-20220215182752408](http://book.bikongge.com/sre/2024-linux/image-20220215182752408.png)

## rsync+inotify实时同步

![image-20220215183312201](http://book.bikongge.com/sre/2024-linux/image-20220215183312201.png)

## 实时同步结合NFS

![image-20220420191519560](http://book.bikongge.com/sre/2024-linux/image-20220420191519560.png)

```
NFS+实时同步

1.解决了NFS单点故障的问题
2.备份NFS的数据，提供了数据冗余
```

## 实时同步的难点

```
1.什么条件下开始同步
2.同步哪些文件夹
3.多长时间同一次？
4.用什么工具同步？
????
```

# inotify隆重出场

Inotify是一个强大的，细粒度的，异步的文件系统事件监控机制。

事件是指如文件的增删改查都是事件。

Linux2.6.13开始就引入了inotify这个功能，用于监控文件系统的增删改查等事件。

第三方软件能实现监控文件内容变化，其实是因为linux提供了这个inotify机制功能。

![image-20220420195811893](http://book.bikongge.com/sre/2024-linux/image-20220420195811893.png)

# 实施复制软件介绍

| 软件          | 依赖程序      | 部署难点   | 说明             |
| ------------- | ------------- | ---------- | ---------------- |
| Inotify-tools | Rsync守护进程 | 写复制脚本 | 监控目录数据变化 |

Inotify是一种异步的系统事件监控机制，通过Inotify可以监控文件系统中添加、删除、修改等事件，利用这个内核接口，第三方软件可以监控文件系统下的情况变化。

> 那么Inofity-tools就是该类软件的实现，是一个监控指定目录数据实时变化的软件。

1.实时复制软件会监控磁盘文件系统的变化，比如指定的/data目录，实时复制软件进程会实时监控这个/data目录中对应文件系统数据的变化。

2.一旦/data目录文件发生变化，就会执行rsync命令，将变化的数据推送到备份服务器对应的备份目录中

# Inotify+Rsync实施复制实战

Inotify-tools本身的核心功能都是`监控指定目录内的数据变化`，具体的复制到远端服务器的功能还是借助Rsync工具配合，

Inotify机制软件工作流程如下

1. 备份源客户端开机运行Inotify软件，检测指定目录的文件系统变化
2. 一旦获取到指定监控目录的数据发生变化，即刻执行Rsync命令复制数据。
3. 将变化的数据发送到Rsync服务端的备份目录。

# 先准备rsyncd服务环境

## 部署拓扑图

> 部署拓扑图
>
> 以rsync守护进程模式部署，且以远程数据同步方式，由client向server推送数据。

![image-20220216102658896](http://book.bikongge.com/sre/2024-linux/image-20220216102658896.png)

> 我们这里设计的形式是，数据推送

1.准备好rsync服务端，等待客户端发来同步数据。（备份服务器）

2.准备好rsync客户端，结合inotify实现文件更新，主动执行rsync命令推送（开发服务器）

## Backup服务器（rsync服务端）

> 理解rsync部署流程

1.rsync程序安装

2.rsync配置文件修改

3.创建rsync服务特定用户

4.创建rsync数据备份的目录，对特定用户授权

5.创建rsync认证密码文件，修改密码文件权限600

6.启动rsync服务，以守护进程模式

7.设置rsync开机启动

![image-20220216104329862](http://book.bikongge.com/sre/2024-linux/image-20220216104329862.png)

> 具体部署流程就跳过了，看于超老师讲解rsync的博客篇即可。

## dev服务器部署（rsync客户端）

1.确认rsync命令存在

2.创建rsync连接所需的密码文件，授权

> 具体部署流程就跳过了，看于超老师讲解rsync的博客篇即可。

# 准备部署inotify-tools软件（nfs-31机器）

## 内核检查

在上述，确保了，两台机器可以正确进行rsync数据同步后。

我们可以开始部署inotify了

只有Linux内核版本在2.6.13起才支持，以及是否存在三个系统文件，存在则支持

```
[root@nfs-31 ~]#uname -r
3.10.0-862.el7.x86_64

[root@nfs-31 ~]#ls -l /proc/sys/fs/inotify/
total 0
-rw-r--r-- 1 root root 0 Apr 20 20:08 max_queued_events
-rw-r--r-- 1 root root 0 Apr 20 20:08 max_user_instances
-rw-r--r-- 1 root root 0 Apr 20 20:08 max_user_watches

系统文件解释
max_user_watches:    设置inotifywait或inotifywatch命令可以监视的文件数量（单进程）
默认只能监控8192个文件

max_user_instances:    设置每个用户可以运行的inotifywait或inotifywatch命令的进程数
默认每个用户可以开启inotify服务128个进程

max_queued_events:    设置inotify实例事件（event）队列可容纳的事件数量
默认监控事件队列长度为16384
```

## 安装inotifty-tools工具

（需要配置epel源）

```
[root@nfs-31 ~]#yum install inotify-tools -y


检查生成的软件命令
[root@nfs-31 ~]# rpm -ql inotify-tools |head -2
/usr/bin/inotifywait
/usr/bin/inotifywatch
```

## Inotifywait详解

上述操作我们安装好了Inotify-tools软件，生成2个重要的命令

- inotifywait：在被监控的目录等待特定文件系统事件（open、close、delete等事件），执行后处于阻塞状态，适合在Shell脚本中使用，是实现监控的关键
- Inotifywatch：收集被监控的文件系统使用的统计数据（文件系统事件发生的次数统计）

【inotifywait命令解释】

```
inotifywait用于等待文件或文件集上的一个待定事件，可以监控任何文件和目录设置，并且可以递归地监控整个目录树；

inotifywatch用于收集被监控的文件系统计数据，包括每个inotify事件发生多少次等信息

从上面可知inotifywait是一个监控事件，可以配合shell脚本使用它。与它相关的参数：

语法格式：inotifywait [-hcmrq][-e][-t][–format][-timefmt][…]

-m： 即“–monitor” 表示始终保持事件监听状态。

-d：类似于-m参数，将命令运行在后台，记录出发的事件信息，记录在指定文件里，加上--outfile参数

-r： 即“–recursive” 表示递归查询目录

-q： 即“–quiet” 表示打印出监控事件

-o： 即“–outfile” 输出事情到一个文件而不是标准输出

-s: 即“–syslog” 输入错误信息到系统日志

-e： 即“–event”， 通过此参数可以指定要监控的事件，常见的事件有modify、delete、create、close_write、move、close、unmount和attrib等


-format： 指定输出格式；常用的格式符如：

%w：表示发生事件的目录

%f：表示发生事件的文件

%e：表示发生的事件

%Xe:事件以“X”分隔

%T：使用由-timefmt定义的时间格式

-timefmt：指定时间格式，用于-format选项中的%T格式
```

利用Inotify软件监控的事件主要是如下，也是我们使用命令，需要指定的那些事件，指的就是你想监控文件内容变化了，还是被删了，还是正在被编辑，被修改，等情况。

```
Events    含义
access    文件或目录被读取
modify    文件或目录内容被修改
attrib    文件或目录属性被改变
close    文件或目录封闭，无论读/写模式
open    文件或目录被打开
moved_to    文件或目录被移动至另外一个目录
move    文件或目录被移动到另一个目录或从另一个目录移动至当前目录
create    文件或目录被创建在当前目录
delete    文件或目录被删除
umount    文件系统被卸载
```

关于监控事件的细节解释

```
可监控的事件
有几种事件能够被监控。一些事件，比如 IN_DELETE_SELF 只适用于正在被监控的项目，而另一些，比如 IN_ATTRIB 或者 IN_OPEN 则只适用于监控过的项目，或者如果该项目是目录，则可以应用到其所包含的目录或文件。

IN_ACCESS
被监控项目或者被监控目录中的条目被访问过。例如，一个打开的文件被读取。
IN_MODIFY
被监控项目或者被监控目录中的条目被修改过。例如，一个打开的文件被修改。
IN_ATTRIB
被监控项目或者被监控目录中条目的元数据被修改过。例如，时间戳或者许可被修改。
IN_CLOSE_WRITE
一个打开的，等待写入的文件或目录被关闭。
IN_CLOSE_NOWRITE
一个以只读方式打开的文件或目录被关闭。
IN_CLOSE
一个掩码，可以很便捷地对前面提到的两个关闭事件（IN_CLOSE_WRITE | IN_CLOSE_NOWRITE）进行逻辑操作。
IN_OPEN
文件或目录被打开。
IN_MOVED_FROM
被监控项目或者被监控目录中的条目被移出监控区域。该事件还包含一个 cookie 来实现 IN_MOVED_FROM 与 IN_MOVED_TO 的关联。
IN_MOVED_TO
文件或目录被移入监控区域。该事件包含一个针对 IN_MOVED_FROM 的 cookie。如果文件或目录只是被重命名，将能看到这两个事件，如果它只是被移入或移出非监控区域，将只能看到一个事件。如果移动或重命名一个被监控项目，监控将继续进行。参见下面的 IN_MOVE-SELF。
IN_MOVE
可以很便捷地对前面提到的两个移动事件（IN_MOVED_FROM | IN_MOVED_TO）进行逻辑操作的掩码。
IN_CREATE
在被监控目录中创建了子目录或文件。
IN_DELETE
被监控目录中有子目录或文件被删除。
IN_DELETE_SELF
被监控项目本身被删除。监控终止，并且将收到一个 IN_IGNORED 事件。
IN_MOVE_SELF
监控项目本身被移动。
```

## inotifywait实践

![image-20220216135707350](http://book.bikongge.com/sre/2024-linux/image-20220216135707350.png)

使用参数解释

```
命令用法
inotifywait -mrq   --timefmt "%d/%m/%y %H:%M" --format "%T %w%f" /yuchao-data


-m： 即“–monitor” 表示始终保持事件监听状态。
-r： 即“–recursive” 表示递归查询目录
-q： 即“–quiet” 表示打印出监控事件
-e： 即“–event”， 通过此参数可以指定要监控的事件，常见的事件有modify、delete、create、close_write、move、close、unmount和attrib等



--timefmt：指定时间格式
%m 　月份(以01-12来表示)。
%d 　日期(以01-31来表示)。
%y 　年份(以00-99来表示)。
%F  

%w：表示发生事件的目录
%f：表示发生事件的文件
%T：使用由-timefmt定义的时间格式
%e：表示发生的事件
```

当我们的代码目录，有了更新，希望立即实现数据同步，即可检测create事件。

### 所有事件

执行命令，以及对日志进行格式化，默认检测所有事件

```
[root@nfs-31 ~]#inotifywait -mrq --timefmt "%F" --format "%T %w%f 捕获到的事件是：%e" /yuchao-data

默认程序会夯住，正在监测事件中
```

![image-20220420201907287](http://book.bikongge.com/sre/2024-linux/image-20220420201907287.png)

### Create、delete

```
inotifywait -mrq   --timefmt "%d/%m/%y %H:%M" --format "%T %w%f" -e create,delete  /yuchao-data
```

![image-20220420202057913](http://book.bikongge.com/sre/2024-linux/image-20220420202057913.png)

### move事件

```
inotifywait -mrq --timefmt "%F" --format "%T %w %f 捕获到的事件是：%e"  -e move /yuchao-data
```

![image-20220420202253399](http://book.bikongge.com/sre/2024-linux/image-20220420202253399.png)

可以知道，inotiify的作用是，基于不同的事件，检测文件夹中，文件的变化。

当检测到有事件发生后，证明文件变化，我们可以执行数据同步rsync操作了。

### close_write事件

```
IN_CLOSE_WRITE
一个打开的，等待写入的文件或目录被关闭。

inotifywait -mrq --timefmt "%F" --format "%T %w %f 捕获到的事件是：%e"  -e close_write /yuchao-data
```

![image-20220420202527891](http://book.bikongge.com/sre/2024-linux/image-20220420202527891.png)

# inotify结合rsync实时同步

可知，这个工具的用法就是

1.inotify检测文件变化

2.执行rsync同步

那么想自动化实现的话，手工是不行了，就的结合脚本实现。

## 数据实时监测备份

### 简单看一下shell语法

1.脚本如下，这里需要跟着超哥学完shell编程之后，方可理解。 先看下shell脚本，如何检测到文件内容的变化

```
1.生成一个普通文本
[root@yuchao-dev01 data]# seq 10 > yuchao.txt
[root@yuchao-dev01 data]#
[root@yuchao-dev01 data]# cat yuchao.txt
1
2
3
4
5
6
7
8
9
10

2.来看一个简单的循环shell脚本
[root@yuchao-dev01 data]# vim about_while.sh
[root@yuchao-dev01 data]#
[root@yuchao-dev01 data]# cat about_while.sh
cat yuchao.txt |while read line
do
    echo 当前行内容是：$line
done

3.执行脚本
[root@yuchao-dev01 data]# pwd
/data
[root@yuchao-dev01 data]# ls
about_while.sh  yuchao.txt

[root@yuchao-dev01 data]# sh about_while.sh
当前行内容是：1
当前行内容是：2
当前行内容是：3
当前行内容是：4
当前行内容是：5
当前行内容是：6
当前行内容是：7
当前行内容是：8
当前行内容是：9
当前行内容是：10
```

### 改造脚本结合rsync

这个脚本作用是让shell的while循环，不断的读取，文件内容

> 因此也可以用来读取inotifywait检测的日志信息，一旦有新日志出现，我们就执行rsync同步，实现（文件内容检测+rsync同步）

改造脚本，脚本需求是

1.开发机器上的代码目录，一旦有代码更新，执行rsync，将代码文件发给备份服务器

```
[root@yuchao-dev01 data]# cat about_inotify.sh
#!/bin/bash
path=/yuchao-data
backup_server=172.16.1.41
export RSYNC_PASSWORD=chaoge666

/usr/bin/inotifywait -mrq -e modify,delete,create,attrib,move /yuchao-data | while read line
do
    echo ${line}
    rsync -az --delete /yuchao-data/ rsync_backup@${backup_server}::data
done
```

参数解释

```
# 参数解释
-m 保持监控状态
-r 递归监控
-q 只打印事件
-e 指定事件

事件：
move    移动
delete    删除
create    创建
modify    修改
attrib    属性信息
```

添加权限，执行脚本

```
[root@nfs-31 ~]#./test_inotify.sh
```

### 测试脚本结果

1.写入数据；2.查看rsync是否有数据同步 ；3.删除事件也支持

![image-20220420203717815](http://book.bikongge.com/sre/2024-linux/image-20220420203717815.png)

## 总结inotify

```
优点：
1.linux内核本身支持inotify机制
2.用于监控文件系统事件变化的神器

缺点：
1.如果并发修改的文件超过200个，同步会延迟，以及会丢掉部分文件，这是inotifywait软件的bug，官网有说明。

2.该脚本监控到事件后，调用rsync是单进程执行，一次cpu只会同步一次rsync命令，效率很低，大数据量下没法使用。
3.自己写的脚本，其实问题还是很多的，简单场景没问题，高并发，复杂场景下，要求多的情况下，那就有点羞涩了。
4.其实已经有了更牛b的程序员，开发了第三方工具，强化了inotify的作用，再结合rsync实现实时同步。
```

# 基于sersync工具同步（了解）

https://code.google.com/archive/p/sersync/ 关于软件的下载地址，以及项目介绍，作者介绍。

提到数据同步就必然会谈到rsync，一般简单的服务器数据传输会使用ftp/sftp等方式，但是这样的方式效率不高，不支持差异化增量同步也不支持实时传输。

针对数据实时同步需求大多数人会选择rsync+inotify-tools的解决方案。

sersync是国人基于前两者开发的工具，不仅保留了优点同时还强化了实时监控，文件过滤，简化配置等功能，帮助用户提高运行效率，节省时间和网络资源。

Sersync项目利用Inotify和Rsync工具技术实现对服务器数据实时复制。

当事件发生变化后，利用rsync命令把变化的数据复制到远端服务器上。

Sersync特点

- 使用C++编写，支持对监控事件的过滤
- Sersync采用xml配置文件，由守护进程启动，配置起来比起简易的`inotify+rsync更简单`
- 使用多线程复制，可以并发复制多个不同文件，效率更高
- Sersync自带异常检测机制，可以通过`失败队列`对出错的文件重新复制
- 自带crontab功能，实现对`失败队列`中的文件定时整体复制
- 自带socket和HTTP协议扩展，定制特殊需求，二次开发

## 机器准备

```
nfs-31  172.16.1.31 rsync+intofiy+sersync

rsync-41   172.16.1.41  rsyncd服务
```

## 安装sersync程序

```
1.下载
cd /opt && wget https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/sersync/sersync2.5.4_64bit_binary_stable_final.tar.gz

2.解压缩
[root@nfs-31 /opt]#ls
GNU-Linux-x86  sersync2.5.4_64bit_binary_stable_final.tar.gz

3.重命名，查看配置文件
[root@nfs-31 /opt]#mv GNU-Linux-x86 sersync-2-5-4
[root@nfs-31 /opt]#cd sersync-2-5-4/
[root@nfs-31 /opt/sersync-2-5-4]#cp confxml.xml confxml.xml.bak


4.该软件就俩文件，一个二进制，一个配置文件
[root@nfs-31 /opt/sersync-2-5-4]#ls
confxml.xml  confxml.xml.bak  sersync2
[root@nfs-31 /opt/sersync-2-5-4]#file sersync2 
sersync2: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.15, BuildID[sha1]=c41f3d73f3d4fe1d6931d93a4e64fe805769b28f, stripped
[root@nfs-31 /opt/sersync-2-5-4]#
[root@nfs-31 /opt/sersync-2-5-4]#file confxml.xml
confxml.xml: XML 1.0 document, ASCII text
```

## 配置文件修改

其中confxml.xml是配置文件，文件内容很容易理解。以下是示例文件内容说明。

```
注意，确保你的rsync服务正常，以你的rsyncd服务端的配置信息填写
```

![image-20220421161444714](http://book.bikongge.com/sre/2024-linux/image-20220421161444714.png)

```
 23     <sersync>
 24         <localpath watch="/data">
 25             <remote ip="172.16.1.41" name="data"/> # rsyncd服务器地址以及模块名
 26             <!--<remote ip="192.168.8.39" name="tongbu"/>-->
 27             <!--<remote ip="192.168.8.40" name="tongbu"/>-->
 28         </localpath>
 29         <rsync>
 30             <commonParams params="-az"/> # rsync参数
 31             <auth start="true" users="rsync_backup" # rsync认证用户 passwordfile="/etc/rsync.passwd"/>
```

## 命令解释

```
[root@nfs-31 /opt/sersync-2-5-4]#./sersync2 -h
set the system param
execute：echo 50000000 > /proc/sys/fs/inotify/max_user_watches
execute：echo 327679 > /proc/sys/fs/inotify/max_queued_events
parse the command param
_______________________________________________________
参数-d:启用守护进程模式
参数-r:在监控前，将监控目录与远程主机用rsync命令推送一遍
c参数-n: 指定开启守护线程的数量，默认为10个
参数-o:指定配置文件，默认使用confxml.xml文件
参数-m:单独启用其他模块，使用 -m refreshCDN 开启刷新CDN模块
参数-m:单独启用其他模块，使用 -m socket 开启socket模块
参数-m:单独启用其他模块，使用 -m http 开启http模块
不加-m参数，则默认执行同步程序
________________________________________________________________
[root@nfs-31 /opt/sersync-2-5-4]#
```

## 启动sersync程序

```
[root@nfs-31 /opt/sersync-2-5-4]#./sersync2 -rdo confxml.xml
```

## 检查数据是否同步

### rsync服务端

```
[root@rsync-41 ~]#cd /data
[root@rsync-41 /data]#ls
[root@rsync-41 /data]#while true;do ls ;sleep 0.1;done
```

![image-20220421162902991](http://book.bikongge.com/sre/2024-linux/image-20220421162902991.png)

### nfs-31 客户端

![image-20220421162927905](http://book.bikongge.com/sre/2024-linux/image-20220421162927905.png)

## 总结sersync

```
1.金山软件、花椒直播的技术总监开发而来，开源免费

2.缺点，缺少了后期的维护，性能存在问题，小规模生产环境已经可以直接使用了
```

# lsyncd工具（推荐使用）

```
https://github.com/lsyncd/lsyncd

Lysncd 实际上是lua语言封装了 inotify 和 rsync 工具，采用了 Linux 内核（2.6.13 及以后）里的 inotify 触发机制，然后通过rsync去差异同步，达到实时的效果。
我认为它最令人称道的特性是，完美解决了 inotify + rsync海量文件同步带来的文件频繁发送文件列表的问题 —— 通过时间延迟或累计触发事件次数实现。
另外，它的配置方式很简单，lua本身就是一种配置语言，可读性非常强。
lsyncd也有多种工作模式可以选择，本地目录cp，本地目录rsync，远程目录rsyncssh。

实现简单高效的本地目录同步备份（网络存储挂载也当作本地目录），一个命令搞定。
```

## lsyncd安装

```
[root@nfs-31 /data]#yum install lsyncd -y
```

## 修改配置文件

只监控一个目录

```lua
[root@nfs-31 /data]#cat /etc/lsyncd.conf 

settings {
    logfile      ="/var/log/lsyncd/lsyncd.log",
    statusFile   ="/var/log/lsyncd/lsyncd.status",
    inotifyMode  = "CloseWrite",
    maxProcesses = 8,
    }

sync {
    default.rsync,
    source    = "/data",
    target    = "rsync_backup@172.16.1.41::data",
    delete= true,
    exclude = {".*"},
    delay=1,
    rsync     = {
        binary    = "/usr/bin/rsync",
        archive   = true,
        compress  = true,
        verbose   = true,
        password_file="/etc/rsync.passwd",
        _extra={"--bwlimit=200"}
        }
    }
```

监控2个目录

```lua
[root@nfs-31 /data]#cat /etc/lsyncd.conf 

settings {
    logfile      ="/var/log/lsyncd/lsyncd.log",
    statusFile   ="/var/log/lsyncd/lsyncd.status",
    inotifyMode  = "CloseWrite",
    maxProcesses = 8,
    }

sync {
    default.rsync,
    source    = "/data",
    target    = "rsync_backup@172.16.1.41::data",
    delete= true,
    exclude = {".*"},
    delay=1,
    rsync     = {
        binary    = "/usr/bin/rsync",
        archive   = true,
        compress  = true,
        verbose   = true,
        password_file="/etc/rsync.passwd",
        _extra={"--bwlimit=200"}
    }
}

sync {
    default.rsync,
    source    = "/backup",
    target    = "rsync_backup@172.16.1.41::backup",
    delete= true,
    exclude = {".*"},
    delay=1,
    rsync     = {
        binary    = "/usr/bin/rsync",
        archive   = true,
        compress  = true,
        verbose   = true,
        password_file="/etc/rsync.passwd",
        _extra={"--bwlimit=200"}
    }
}
```

## 配置文件详解

```
syncd.conf配置选项说明
settings
里面是全局设置，--开头表示注释，下面是几个常用选项说明：

logfile 定义日志文件
stausFile 定义状态文件
nodaemon=true 表示不启用守护模式，默认
statusInterval 将lsyncd的状态写入上面的statusFile的间隔，默认10秒
inotifyMode 指定inotify监控的事件，默认是CloseWrite，还可以是Modify或CloseWrite or Modify
maxProcesses 同步进程的最大个数。假如同时有20个文件需要同步，而maxProcesses = 8，则最大能看到有8个rysnc进程
maxDelays 累计到多少所监控的事件激活一次同步，即使后面的delay延迟时间还未到
sync
里面是定义同步参数，可以继续使用maxDelays来重写settings的全局变量。一般第一个参数指定lsyncd以什么模式运行：rsync、rsyncssh、direct三种模式：

default.rsync ：本地目录间同步，使用rsync，也可以达到使用ssh形式的远程rsync效果，或daemon方式连接远程rsyncd进程；
default.direct ：本地目录间同步，使用cp、rm等命令完成差异文件备份；
default.rsyncssh ：同步到远程主机目录，rsync的ssh模式，需要使用key来认证

source 同步的源目录，使用绝对路径。

target 定义目的地址.对应不同的模式有几种写法：
/tmp/dest ：本地目录同步，可用于direct和rsync模式
172.29.88.223:/tmp/dest ：同步到远程服务器目录，可用于rsync和rsyncssh模式，拼接的命令类似于/usr/bin/rsync -ltsd --delete --include-from=- --exclude=* SOURCE TARGET，剩下的就是rsync的内容了，比如指定username，免密码同步
172.29.88.223::module ：同步到远程服务器目录，用于rsync模式
三种模式的示例会在后面给出。

init 这是一个优化选项，当init = false，只同步进程启动以后发生改动事件的文件，原有的目录即使有差异也不会同步。默认是true

delay 累计事件，等待rsync同步延时时间，默认15秒（最大累计到1000个不可合并的事件）。也就是15s内监控目录下发生的改动，会累积到一次rsync同步，避免过于频繁的同步。（可合并的意思是，15s内两次修改了同一文件，最后只同步最新的文件）

excludeFrom 排除选项，后面指定排除的列表文件，如excludeFrom = "/etc/lsyncd.exclude"，如果是简单的排除，可以使用exclude = LIST。
这里的排除规则写法与原生rsync有点不同，更为简单：

监控路径里的任何部分匹配到一个文本，都会被排除，例如/bin/foo/bar可以匹配规则foo
如果规则以斜线/开头，则从头开始要匹配全部
如果规则以/结尾，则要匹配监控路径的末尾
?匹配任何字符，但不包括/
*匹配0或多个字符，但不包括/
**匹配0或多个字符，可以是/
delete 为了保持target与souce完全同步，Lsyncd默认会delete = true来允许同步删除。它除了false，还有startup、running值，请参考 Lsyncd 2.1.x ‖ Layer 4 Config ‖ Default Behavior。

rsync
（提示一下，delete和exclude本来都是rsync的选项，上面是配置在sync中的，我想这样做的原因是为了减少rsync的开销）

bwlimit 限速，单位kb/s，与rsync相同（这么重要的选项在文档里竟然没有标出）
compress 压缩传输默认为true。在带宽与cpu负载之间权衡，本地目录同步可以考虑把它设为false
perms 默认保留文件权限。
其它rsync的选项
其它还有rsyncssh模式独有的配置项，如host、targetdir、rsync_path、password_file，见后文示例。rsyncOps={"-avz","--delete"}这样的写法在2.1.*版本已经不支持。

lsyncd.conf可以有多个sync，各自的source，各自的target，各自的模式，互不影响。
```

## 启动lsyncd服务

```
systemctl start lsyncd
```

## 测试数据写入

### Nfs-31

```
[root@nfs-31 /data]#for i in {1..100};do echo ${i};echo ${i} > ${i}.log;sleep 0.1;done
```

### rsync-41

```
[root@rsync-41 /data]#for i in {1..100};do ls;sleep 0.1;done
```

![image-20220421171427352](http://book.bikongge.com/sre/2024-linux/image-20220421171427352.png)

# 实时同步方案总结

- inotify+rsync，可以用于小数据量的实时备份，需要自己编写脚本，问题较多；
- sersync工具还不错，可以用于小规模的生产环境；
- 目前最好用的是lsyncd工具，支持很多高级功能（要求需要学习lua脚本语言方可掌握），适用于生产环境的复杂运维数据同步业务。